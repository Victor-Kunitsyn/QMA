#pragma once

#include <vector>
#include "QuestRemoteDevice.h"
#include "QuestRemoteSensor.h"

enum ESensorEvent
{
    LISTENING_CONTINUE = 0,

    ALARM_ON = 1,
    ALARM_OFF = 2,
    ALARM_CONTINUE = 3,
    
    DISARM_ON = 4,
    DISARM_OFF = 5,
    DISARM_CONTINUE = 6,

    SLEEP_ON = 7,
    SLEEP_OFF = 8,
    SLEEP_CONTINUE = 9,

    LAST_SENSOR_EVENT = 10
};

struct SSensorExecutionEvent
{
    SSensorExecutionEvent() : sensor_ordinal_number(-1), sensor_event(LAST_SENSOR_EVENT) {}
    SSensorExecutionEvent(int ord, ESensorEvent s_event) : sensor_ordinal_number(ord), sensor_event(s_event) {}

    int sensor_ordinal_number;
    ESensorEvent sensor_event;
};

enum ELevel
{
    ORDINARY = 0,
    EXPERT = 1,
    LEVEL_BOUND = 2
};

struct SExecuterParameters
{
    SExecuterParameters() : should_redo_if_executer_was_deactivated(false),
                            should_log_action_execution(true),
                            should_transform_parameter_on_execution_time(true) {}

    std::string executer_parameters[LEVEL_BOUND];
    
    bool should_redo_if_executer_was_deactivated;
    bool should_log_action_execution;
    bool should_transform_parameter_on_execution_time;
};

struct SSensorsConnection
{
    SSensorsConnection() : executer_ordinal_number(-1) {}

    std::vector<SSensorExecutionEvent> sensor_events_for_executer;
    int executer_ordinal_number;
    std::vector<SExecuterParameters> exec_params; //execution' parameter can depend on step number, vector must contain at least one element
};

struct SExecutionContext
{
    SExecutionContext() : executer_ordinal_number(-1) {}
    
    int executer_ordinal_number;
    SExecuterParameters exec_param;
};

typedef CRemoteDevice* (*ptr_Device_Creator)(const char* device_type, 
											 const std::string& ip, int port, const std::string& usr, const std::string& psw,
											 int id, int request_threshold, const std::string& name);

#define OK								0
#define ERROR_THREAD					-1
#define ERROR_STATUS					-2

class CLogger;
class CMainServer;

class CRemoteDevicesManager
{
public:
    CRemoteDevicesManager(const CMainServer* main_server_ptr);
    virtual ~CRemoteDevicesManager();

public:
    bool Init(const char* ini_file_full_path, ptr_Device_Creator remote_device_factory);

public:
    short ActivateSystem(bool need_log_start_info) const;
    
    short ActivateAllDevices() const;
    short ActivateNextDevice() const;

    short DeActivateSystem() const;
    
    short CheckSystem() const;

    void ProcessSensors(ELevel level, DWORD quest_number_of_get_sensor_states_attempts) const;
    void ProcessExecuters(ELevel level) const;

	bool SensorStatesObtaining() const { return ((int_get_sensor_state_attempts > 0) || should_restore_sensor_states);  }

public:
	const CMainServer* GetServer() const { return main_server; }
	const std::vector<CRemoteDevice*>& GetDevices() const { return devices; }
	const ESensorState* GetSensorStates() const { return sensor_states; }
    const CLogger* GetLogger() const { return ptr_logger; }

private:
    bool InitDevices(int num_devices, const char* ini_file_full_path, ptr_Device_Creator remote_device_factory);
    bool InitConnections(const char* ini_file_full_path);

    static ESensorEvent CalculateSensorEvent(ESensorState cur_state, ESensorState prev_state);
    
    void Clear();
    
    void SetSensorStatesActivated() const;
    void SetSensorStatesDeActivated() const;

    bool IsAllDevicesActivated() const;
    ERemoteDeviceResponse IsObligatoryDevicesActivated() const;

    short ActivateDevice(int device_ind) const;

    short DeActivateAllDevices() const;
    
    short RestoreSensorStates() const;
    ERemoteDeviceResponse GetCurrentSensorStates() const;

    void ProcessConnections(const ESensorEvent* sensor_events) const;

private:
    const CMainServer* main_server;

    std::vector<CRemoteDevice*> devices;
    
    int* max_number_of_sensor_alarms; //if max_number_of_alarms (ALARM_ON event) is achieved, sensor goes to SLEEP state
    int* sensor_alarms_count; //number of ALARM_ON events, generated by the corresponding sensor

    DWORD* sensors_max_times_in_alarm_mode; //if max_time_in_alarm_mode is achieved, sensor goes to ACTIVATED state
    DWORD* sensors_start_alarm_times;
    
    std::vector<SSensorsConnection> sensor_connections;
    int* connection_processings_count;
    
    mutable ESensorState* sensor_states; //should restore it, if sensor hardware was rebooted 
    mutable ESensorState* current_states;
    mutable bool should_restore_sensor_states;
    mutable int int_get_sensor_state_attempts; 

    mutable std::vector<SExecutionContext> devices_execute_actions;
    mutable std::vector< std::vector<std::string> > devices_saved_execution_parameters;

    mutable int current_device_index_to_activate;

    const CLogger* ptr_logger;
};